---
layout: post
title: "Ruby学习笔记（二） 集合、方法"
categories:
  - Ruby
tags:
  - Ruby
last_modified_at: 2017-01-20 13:19:38 +08:00
---

* content
{:toc}
这是我在学习 [SoloLearn](https://www.sololearn.com/) 的 [Ruby Tutorial](https://www.sololearn.com/Course/Ruby/) 时的笔记的第二部分，包括Ruby编程中的Collections集合与Methods方法。具体包括数组的相关操作、Hash（哈希，散列）的相关操作、迭代器、字符串的一些操作、方法（Method）的定义及调用、方法参数及返回值的研究。



在本文中我省略了该课程中的一些编程的基础概念，并且将Ruby的语法与其它语言的进行了一些比较，适合已经有一些其它编程语言的基础的朋友阅读。文中的加粗内容表示跟我以前接触过的其它语言（C/C++/Java/Javascript）看起来相似但不一致的地方。由于我水平有限，错误在所难免，如发现错误请在留言内指教，谢谢！

本文在本人新博客的链接：[http://www.myblog.link/2017/01/18/Note-of-Ruby-2/](http://www.myblog.link/2017/01/18/Note-of-Ruby-2/)

## 集合

### 数组基础

- 声明：`数组名 = ["用逗号间隔的元素1","用逗号间隔的元素2","用逗号间隔的元素n"]`，各**元素的类型可以不一致**。数组可嵌套，将另一个数组作为数组的元素即可，如`a = [ [1,2] , [3,4,5] ]`，这样可以形成**每维长度可以不一致**的多维数组。

- 访问元素：`数组名[数组下标]`：

  - 从0开始的非负数表示从开始数起的下标，如`a[0]`表示数组`a`的第一个元素。
  - **负数表示从数组结尾数起的下标**，如`a[-1]`表示数组`a`的最后一个元素。
  - 也可以用`a[首..尾]`和`a[首...尾]`访问数组的一个区间。

- 输出整个数组：

  - `puts 数组名` 每行输出一个数组元素。
  - `print 数组名` 在一行输出数组所有元素，首尾带括号，中间以逗号分隔。

- 添加元素：

  - `数组名 << 值`或者`数组名.push(值)` 将值加入该数组末尾。
  - `数组名.insert(下标,值)` 将值插入该数组指定位置。

- 删除元素：

  - `数组名.pop` 删除数组的最后一个元素。
  - `数组名.delete_at(下标)` 删除数组指定元素。

###  数组操作

设有数组a、b，则：

- `a + b` 合并数组a、b，简单地将数组b的元素放在数组a的元素之后形成一个新的数组。
- `a - b` 数组a中的元素去掉也包含在数组b中的，形成一个新数组。
- `a & b` 求数组a、b元素的交集，即一个包含 既在a中也在b中的 所有元素 的新数组，无重复元素。
- `a | b` 求数组a、b元素的并集，即一个包含 　在a中或者b中的 所有元素 的新数组，无重复元素。
- `a.reverse` 返回一个新的数组，内容为原数组a中的元素逆序后的结果。
- `a.reverse!` 将数组a中的元素的逆序。
- `a.length` `a.size` 返回数组a的元素个数。
- `a.sort` 返回一个**新数组**，内容为原数组a中的元素排序后的结果。
- `a.uniq` 返回一个新数组，内容为原数组a中的元素去重后的结果。
- `a.uniq!` 将数组a中的元素去重。
- `a.freeze` 保护数组a不被修改。
- `a.include?(元素)`返回数组a中是否包含该元素（`true` or `false`）。
- `a.min` 返回数组a中最小的元素。
- `a.max` 返回数组a中最大的元素。

### Hash 与 Symbol

- symbol：`:名称` 表示一个symbol，如`:id`

- hash：hash（哈希，散列？翻译成什么呢，干脆继续叫hash吧）是键到值的映射，键可以为字符串或者symbol，值可以为任意类型，且各值可以不为同一类型。

  可以这样创建hash：

  - `hash名 = {"键名1字符串" => 键值1, "键名2字符串" => 键值2, "键名n字符串" => 键值n}` 

  - `hash名 = {:symbol1 => 键值1, :symbol2 => 键值2, :symboln => 键值n}`

  - `hash名 = {symbol1: 键值1, symbol2: 键值2, symboln: 键值n}`，**注意冒号前不能有空格**，后面可以有也可以没有

  hash也可以嵌套，将另一个hash作为一个键对应的值即可。

- `hash名["键名字符串"]` 或者 `hash名[:symbol]` 可以用来根据键来取值。

- hash相关函数。设有一个hash名为hash，一个键为key，一个值为value，则有：

  - `hash.delete(key)` 删除hash中键为key的键值对。
  - <del>`hash.index(value)`</del> `hash.key(value)` 返回值为value的*一个* 键，若不存在则返回`nil`。
  - `hash.invert` 返回一个新的hash，其键为原hash的值，值为原hash的键。
  - `hash.keys` 将hash中的所有键作数组返回。
  - `hash.values` 将hash中的所有值作数组返回。
  - `hash.length` 返回hash的长度。
  - `hash.default=` 设置hash的默认值，即不存在相应的键时取到的值，如不更改默认应该是`nil`。

### 迭代器

- `each` 迭代器：对数组或者hash的每一个元素进行操作，例如：

  ``` ruby
  a = [1, 2, 3]
  a.each do |x| # 将数组a的每个元素赋给变量x
    puts x
  end

  hash = {key1: "value1", key2: "value2"} # 注意冒号前不能有空格，后面可以有也可以没有
  hash.each do |key,value|	# 将每个键值对的键赋给变量key，值赋给变量value，变量名可自定义
    puts "key=#{key},value=#{value}"
  end

  # Ruby中的 do 和 end 可以用{}代替，如上面的遍历hash的例子可以写成
  hash.each { |key,value|
    puts "key=#{key},value=#{value}"
  }
  ```

- `times` 迭代器：用于整数，指定循环该整数次，如以下代码输出10次Hello World（用`{` `}`替换了 `do` 与 `end` 并省略了换行的写法，还是挺简洁的）：

  ``` ruby
  10.times{puts "Hello Wolrd"}
  ```

### 字符串杂项

- `each_char` 迭代器：类似数组的`each`迭代器。
- `字符串.downcase!` 将原字符串转为小写。

## 方法

### 方法的定义与调用

- 使用`def`来定义方法:

  ``` ruby
  def 方法名(参数1, 参数2 = 该参数默认值, 参数n)
    # 方法里的语句
    return 要返回的值（表达式）
  end
  ```

- 参数可以没有，可以为固定数量，也可以为不固定数量，还可以给参数默认值。**无论有没有参数，方法名后的括号都可以省略（包括调用的时候）**。参数不固定个数，则使用一个数组作为最后一个参数，调用时多出的参数将会被作为数组元素储存，如：

  ``` ruby
  def foo a,b,*p  # 调用时，第三个及以后的参数会变成数组p的元素（这个*p长得挺像C的指针啊）
    print a,b,p
  end
  foo 1,2,3,4,5,6  # 输出 12[3, 4, 5, 6]
  ```

- `return` 语句可以返回**多个值作为返回值**，如果没有`return` 语句，则**最后一个语句的值**将会被返回，如：

  ``` ruby
  def foo1(a,b)
    return a + 1,b * 3
  end
  puts foo1(1,2)	# 输出 2(换行)6

  def foo2(x)
    x += 1
  end
  puts foo2(1)	# 输出 2
  ```

- **方法必须在方法调用之前定义**，调用时使用`方法名(参数1,参数2,参数n)`，前面提到过括号可以省略，那么无参的函数就可以直接`方法名`调用了。

### 变量作用域

- 局部变量以`_`或小写字母开头，只能在定义它的代码块中被访问，与C/C++/Java一致。但写在**函数外面的变量**（个人理解它们类似于C/C++里main函数里的变量，而不是这些语言的全局变量）**不能被其它函数访问**。
- 变量名**以`$`开头的变量为全局变量**，可以在所有地方被访问。


### 递归

- Ruby可以递归（函数自己调用自己），而且很快？（原文说很快，不知道什么意思，难道有优化？改天试试。）